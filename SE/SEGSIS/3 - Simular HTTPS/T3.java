import java.util.Arrays;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.security.MessageDigest;
import java.nio.charset.StandardCharsets;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

/* 
 * Kevin Boucinha
 * p = B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371
 * g = A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5
 * a = 115740200527109164239523414760926155534485715860090261532154107313946218459149402375178179458041461723723231563839316251515439564315555249353831328479173170684416728715378198172203100328308536292821245983596065287318698169565702979765910089654821728828592422299160041156491980943427556153020487552135890973413
 * A = 18415231803A9B7279B065B000528E2E032B1437D8004BAD24B6034BD0C5478FD3F8F78AD818BA2EC90F4291C742C0B75D46D418EAA64AEEEBD3B86B5BEFCB1A6F88FD0EE7E0E2C6A931ADFB1E10D7B63CAE0D1DD1A030AF2218988854D70C1DE519175C879C64A36B98542EB4369B5083FFFF0AF309B5AF3C8AC0B478B59A11
 * B = 11F734351792398A1EE4FEACD1966515916E82CA09EE6C271B62A2F7B8D7278AB71AD451ACDDDC4607C1EA0E5EB714E2C4A54B62767DA1CBFDD665A578551053D685728C7341BF6DA8CA662B67D99D7E82C7F121F590C26332590F4C930CC09BC5D3F00F57CFDB4000C71C58A131CD61229CE5616E140D6FB736495A506E602D
 * V = 35642747111730485180311272299933506773737884656088586133038601616139651160807935102630464861923038131330982184165165557833998909011835319610567133606525362396129354301869956974583667971264420426326168285414384975244132795090561444348113102943548170609487854043158070581443608314067206219266396359203440364251
 * msg = 5DCA846D30700B26B5D66C6894EF8130AB0DEB1FC94FEDA04CE2BE889B6B4C12C577931C924421E325F5D7337D41E13ADB01C2BEF2680B4B233E62B3BBC9B19391B2F8DF493571E163CDE7248D15F8BB45418966C939CC3798118D686BD7E595BD341B19C0A9899AE6AF2FD38BD1188F
 * plainText = Show Kevin. Agora inverte esta mensagem e me envia ela de volta cifrada com a mesma senha
 * cipherText = 21115C17B0C355214B97B31FE5E7A288DBADCFB65F4AF5719A69A01A990D212BD470C83BA121B8C153E755948F26AF3B065C5EDB189409DF0D6CBA97772A4FADDC4409396EEF2ADBD6B0F26A8783EB9DF8C5B97159A6B592B09607DE168FC82D272BF6BA68F188101FC33C231D11963B
 * msg_final = 1A205A32721043A7D09929D2FDB0DCD772E2AE730D8D3A320B65649A5E870D15DEAD9901B665F79B39E3D4322F86405DBAEECCF60727A450E08063AC7CA15D9C543BB2F5E5D17C9143D2F15E68FD2C99FEF2176D141948B46F5434214F2D8879B92C07302F1522FA73F4B30E31A50DB7ED87149CBC18DFF64AAE0ADA13E0B22758B0025A3590A296BBE786C5E7133C80CFA82B3B7D8985EEA5F430742A29FB56
 * plainTextFinal = Perfeito. Agora comenta bem o código colocando este exemplo completo como comentário no início do código e submete o código no Moodle
 * cipherTextFinal = F31AA01AEC8E138653D4302DFF7DC79F78BB7774F5B6BCD138CEED198DC902AB796DAFB31CBBD7AD1BAF4E08A3B8F36E9EE73D73B0A66BB494D12ABF5930C9D7C287AA77AFDE50046426967E710EA815E8A4DDD6BF1784316505A33FDA347DC882645620AEF21048A98398B6A2FFAC94D8889AAED7ACFB560C0164C1C7269F5F5297833797559FBAA41F15A4B15498CEFDD7AFC6126BFD18FC20B242E68C8DA0
*/

public class T3 {

    private static final byte[] HEX_ARRAY = "0123456789ABCDEF".getBytes(StandardCharsets.UTF_8);

    public static void main(String[] args) {
        // número primo
        var p = new BigInteger(
                "B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C69A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C013ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD7098488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708DF1FB2BC2E4A4371",
                16);
        // gerador
        var g = new BigInteger(
                "A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507FD6406CFF14266D31266FEA1E5C41564B777E690F5504F213160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28AD662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24855E6EEB22B3B2E5",
                16);

        // minha chave privada menor que p
        var a = g.pow(1);

        // minha chave pública
        var A = g.modPow(a, p).toString(16).toUpperCase();

        // chave pública do professor
        var B = new BigInteger(
                "11F734351792398A1EE4FEACD1966515916E82CA09EE6C271B62A2F7B8D7278AB71AD451ACDDDC4607C1EA0E5EB714E2C4A54B62767DA1CBFDD665A578551053D685728C7341BF6DA8CA662B67D99D7E82C7F121F590C26332590F4C930CC09BC5D3F00F57CFDB4000C71C58A131CD61229CE5616E140D6FB736495A506E602D",
                16);

        // elemento em comum entre ambos
        var V = B.modPow(a, p);

        byte[] key = new byte[16];
        try {
            var digest = MessageDigest.getInstance("SHA-256");

            // usar os bytes de V para gerar S
            var S = digest.digest(V.toByteArray());
            key = Arrays.copyOf(S, 16);

        } catch (Exception e) {
            System.err.println("Erro ao realizar o hash");
            System.err.println(e);
        }
        var secretKey = new SecretKeySpec(key, "AES");

        // mensagem do professor com iv
        var msg = "1A205A32721043A7D09929D2FDB0DCD772E2AE730D8D3A320B65649A5E870D15DEAD9901B665F79B39E3D4322F86405DBAEECCF60727A450E08063AC7CA15D9C543BB2F5E5D17C9143D2F15E68FD2C99FEF2176D141948B46F5434214F2D8879B92C07302F1522FA73F4B30E31A50DB7ED87149CBC18DFF64AAE0ADA13E0B22758B0025A3590A296BBE786C5E7133C80CFA82B3B7D8985EEA5F430742A29FB56";
        var tmp = hexToByteArray(msg);

        var plainText = "";
        try {
            var cipherText = Arrays.copyOfRange(tmp, 16, tmp.length);
            var iv = Arrays.copyOfRange(tmp, 0, 16);

            var ivSpec = new IvParameterSpec(iv);

            var algorithm = "AES/CBC/PKCS5Padding";
            var cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);

            byte[] result = cipher.doFinal(cipherText);

            plainText = new String(result, StandardCharsets.UTF_8);
            System.out.println(plainText);

        } catch (Exception e) {
            System.err.println("Erro ao decifrar a mensagem");
            System.err.println(e);
        }

        var cipherText = "";
        try {
            var iv = generateIv();
            var ivSpec = new IvParameterSpec(iv);

            var algorithm = "AES/CBC/PKCS5Padding";
            var cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);

            var reversed = new StringBuilder(plainText).reverse().toString();

            var result = cipher.doFinal(reversed.getBytes());

            cipherText = bytesToHex(iv) + bytesToHex(result);
            System.out.println(cipherText);

        } catch (Exception e) {
            System.err.println("Erro ao decifrar a mensagem");
            System.err.println(e);
        }
    }

    public static byte[] generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return iv;
    }

    private static String bytesToHex(byte[] bytes) {
        byte[] hexChars = new byte[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
        }
        return new String(hexChars, StandardCharsets.UTF_8);
    }

    private static byte[] hexToByteArray(String hex) {
        byte[] result = new byte[hex.length() / 2];

        for (int i = 0; i < hex.length(); i += 2) {
            result[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) + Character.digit(hex.charAt(i + 1), 16));
        }

        return result;
    }
}